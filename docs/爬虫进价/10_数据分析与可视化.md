# 第十章：数据分析与可视化

> 本章将学习如何使用 Python 数据分析和可视化工具处理爬取的数据。我们将掌握 pandas 进行数据统计分析、使用词云展示文本数据、利用 matplotlib 和 pyecharts 生成各类图表，最终实现自动化的数据分析报告生成。

## 10.1 数据分析概述

### 为什么需要数据分析

爬虫获取的原始数据只是第一步，真正的价值在于从数据中提取有用的信息和洞察：

- **发现数据规律**：了解数据的分布、趋势和特征
- **验证假设**：用数据验证业务假设和决策
- **支持决策**：为业务决策提供数据依据
- **数据可视化**：将复杂数据转化为直观的图表

### 主要工具介绍

| 工具 | 用途 | 特点 |
|------|------|------|
| pandas | 数据处理和分析 | 功能强大，生态完善 |
| jieba | 中文分词 | 准确率高，易于使用 |
| wordcloud | 词云生成 | 可定制性强 |
| matplotlib | 静态图表 | 功能全面，输出清晰 |
| pyecharts | 交互式图表 | 效果炫酷，支持 Web |

## 10.2 pandas 数据分析

### DataFrame 基础操作

pandas 是 Python 数据分析的核心库，DataFrame 是其最重要的数据结构：

```python
import pandas as pd

# 从爬取的数据创建 DataFrame
data = [
    {"title": "Python 教程", "views": 15000, "likes": 320, "date": "2024-01-15"},
    {"title": "爬虫入门", "views": 12000, "likes": 280, "date": "2024-01-16"},
    {"title": "数据分析", "views": 18000, "likes": 450, "date": "2024-01-17"},
]
df = pd.DataFrame(data)

# 基础信息
print(df.info())    # 列类型和非空数量
print(df.describe())  # 数值列统计摘要

# 数据选择
print(df['title'])           # 选择单列
print(df[['title', 'views']])  # 选择多列
print(df[df['views'] > 14000])  # 条件筛选

# 排序
print(df.sort_values('views', ascending=False))

# 新增列
df['engagement'] = df['likes'] / df['views'] * 100
```

### 数据聚合与分组统计

分组统计是数据分析中最常用的操作：

```python
# 假设有更多数据
data = [
    {"category": "技术", "title": "Python 教程", "views": 15000},
    {"category": "技术", "title": "爬虫入门", "views": 12000},
    {"category": "生活", "title": "美食推荐", "views": 8000},
    {"category": "生活", "title": "旅行日记", "views": 10000},
    {"category": "技术", "title": "数据分析", "views": 18000},
]
df = pd.DataFrame(data)

# 按分类分组统计
grouped = df.groupby('category')
print(grouped['views'].sum())     # 各分类总浏览量
print(grouped['views'].mean())    # 各分类平均浏览量
print(grouped['views'].agg(['sum', 'mean', 'max', 'min']))  # 多个统计量

# 多列聚合
print(df.groupby('category').agg({
    'views': 'sum',
    'title': 'count'
}).rename(columns={'title': 'article_count'}))
```

### 数据透视表

数据透视表可以快速进行多维度分析：

```python
# 更复杂的数据
data = [
    {"date": "2024-01", "category": "技术", "platform": "PC", "views": 15000},
    {"date": "2024-01", "category": "技术", "platform": "Mobile", "views": 8000},
    {"date": "2024-01", "category": "生活", "platform": "PC", "views": 6000},
    {"date": "2024-02", "category": "技术", "platform": "PC", "views": 18000},
    {"date": "2024-02", "category": "生活", "platform": "Mobile", "views": 9000},
]
df = pd.DataFrame(data)

# 创建透视表：按日期和分类统计各平台浏览量
pivot = pd.pivot_table(
    df,
    values='views',
    index='date',
    columns='category',
    aggfunc='sum',
    fill_value=0
)
print(pivot)

# 带边距的透视表
pivot_with_margins = pd.pivot_table(
    df,
    values='views',
    index='date',
    columns='category',
    aggfunc='sum',
    margins=True,
    margins_name='总计'
)
print(pivot_with_margins)
```

### 时间序列分析

爬虫数据通常包含时间维度，时间序列分析很有价值：

```python
# 创建时间序列数据
dates = pd.date_range('2024-01-01', periods=30, freq='D')
views = [1000 + i * 50 + (i % 7) * 200 for i in range(30)]
df = pd.DataFrame({'date': dates, 'views': views})
df.set_index('date', inplace=True)

# 滚动统计（7天移动平均）
df['rolling_avg'] = df['views'].rolling(window=7).mean()

# 按周统计
weekly = df.resample('W').agg({
    'views': ['sum', 'mean']
})
print(weekly)

# 环比增长率
df['growth_rate'] = df['views'].pct_change() * 100
```

## 10.3 词云生成

词云是展示文本数据的直观方式，在分析评论、标题等文本数据时非常有用。

### jieba 中文分词

jieba 是最流行的中文分词库：

```python
import jieba
import jieba.analyse

# 基础分词
text = "Python爬虫教程帮助你快速入门数据采集技术"
words = jieba.lcut(text)
print(words)  # ['Python', '爬虫', '教程', '帮助', '你', '快速', '入门', '数据', '采集', '技术']

# 提取关键词（TF-IDF）
keywords = jieba.analyse.extract_tags(
    text,
    topK=5,
    withWeight=True
)
for word, weight in keywords:
    print(f"{word}: {weight:.4f}")

# 提取关键词（TextRank）
keywords_tr = jieba.analyse.textrank(
    text,
    topK=5,
    withWeight=True
)
```

### 停用词过滤

停用词是指对文本分析没有实际意义的词（如"的"、"是"、"在"等）：

```python
# 常用中文停用词
STOPWORDS = {
    '的', '是', '在', '了', '和', '与', '或', '有', '个', '人',
    '这', '那', '就', '都', '也', '为', '对', '到', '从', '把',
    '被', '让', '给', '向', '往', '于', '及', '以', '等', '不',
    '很', '会', '能', '可', '要', '我', '你', '他', '她', '它',
}

def filter_stopwords(words: list) -> list:
    """过滤停用词和单字"""
    return [
        w for w in words
        if w not in STOPWORDS and len(w) > 1
    ]

# 使用
text = "这是一个关于Python爬虫的教程，帮助你快速入门"
words = jieba.lcut(text)
filtered = filter_stopwords(words)
print(filtered)  # ['Python', '爬虫', '教程', '帮助', '快速', '入门']
```

### 词云生成

使用 wordcloud 库生成词云：

```python
from wordcloud import WordCloud
import matplotlib.pyplot as plt

def generate_wordcloud(
    text: str,
    output_path: str = "wordcloud.png",
    width: int = 800,
    height: int = 600,
    background_color: str = "white",
    font_path: str = None
):
    """
    生成词云图片

    Args:
        text: 空格分隔的词语文本
        output_path: 输出图片路径
        width: 图片宽度
        height: 图片高度
        background_color: 背景颜色
        font_path: 中文字体路径（必须指定才能显示中文）
    """
    # 创建词云对象
    wc = WordCloud(
        width=width,
        height=height,
        background_color=background_color,
        font_path=font_path,  # 中文需要指定字体
        max_words=200,
        max_font_size=100,
        random_state=42
    )

    # 生成词云
    wc.generate(text)

    # 保存图片
    wc.to_file(output_path)

    # 显示词云
    plt.figure(figsize=(10, 8))
    plt.imshow(wc, interpolation='bilinear')
    plt.axis('off')
    plt.tight_layout()
    plt.savefig(output_path.replace('.png', '_display.png'), dpi=150)
    plt.close()

    return output_path


# 完整流程：从文本到词云
def text_to_wordcloud(texts: list, output_path: str, font_path: str = None):
    """从文本列表生成词云"""
    # 1. 分词
    all_words = []
    for text in texts:
        words = jieba.lcut(text)
        all_words.extend(words)

    # 2. 过滤停用词
    filtered_words = filter_stopwords(all_words)

    # 3. 统计词频
    word_freq = {}
    for word in filtered_words:
        word_freq[word] = word_freq.get(word, 0) + 1

    # 4. 生成词云文本
    word_text = ' '.join(filtered_words)

    # 5. 生成词云
    return generate_wordcloud(word_text, output_path, font_path=font_path)
```

### 自定义词云形状

可以使用图片作为词云的形状蒙版：

```python
import numpy as np
from PIL import Image
from wordcloud import WordCloud, ImageColorGenerator

def generate_shaped_wordcloud(
    text: str,
    mask_image_path: str,
    output_path: str,
    font_path: str = None,
    use_mask_colors: bool = True
):
    """
    生成自定义形状的词云

    Args:
        text: 词语文本
        mask_image_path: 形状蒙版图片路径
        output_path: 输出路径
        font_path: 字体路径
        use_mask_colors: 是否使用蒙版图片的颜色
    """
    # 读取蒙版图片
    mask = np.array(Image.open(mask_image_path))

    # 创建词云
    wc = WordCloud(
        mask=mask,
        background_color="white",
        font_path=font_path,
        max_words=500,
        max_font_size=80,
        random_state=42,
        contour_width=1,
        contour_color='steelblue'
    )

    wc.generate(text)

    # 使用蒙版颜色
    if use_mask_colors:
        image_colors = ImageColorGenerator(mask)
        wc.recolor(color_func=image_colors)

    wc.to_file(output_path)
    return output_path
```

## 10.4 数据可视化

### matplotlib 基础图表

matplotlib 是 Python 最基础的可视化库：

```python
import matplotlib.pyplot as plt
import matplotlib
matplotlib.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS']
matplotlib.rcParams['axes.unicode_minus'] = False

def plot_line_chart(
    x_data: list,
    y_data: list,
    title: str,
    xlabel: str,
    ylabel: str,
    output_path: str
):
    """绘制折线图"""
    plt.figure(figsize=(10, 6))
    plt.plot(x_data, y_data, marker='o', linewidth=2, markersize=6)
    plt.title(title, fontsize=14)
    plt.xlabel(xlabel, fontsize=12)
    plt.ylabel(ylabel, fontsize=12)
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()


def plot_bar_chart(
    categories: list,
    values: list,
    title: str,
    xlabel: str,
    ylabel: str,
    output_path: str,
    horizontal: bool = False
):
    """绘制柱状图"""
    plt.figure(figsize=(10, 6))

    if horizontal:
        plt.barh(categories, values, color='steelblue')
        plt.xlabel(ylabel)
        plt.ylabel(xlabel)
    else:
        plt.bar(categories, values, color='steelblue')
        plt.xlabel(xlabel)
        plt.ylabel(ylabel)

    plt.title(title, fontsize=14)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()


def plot_pie_chart(
    labels: list,
    sizes: list,
    title: str,
    output_path: str
):
    """绘制饼图"""
    plt.figure(figsize=(10, 8))

    # 突出最大的一块
    max_idx = sizes.index(max(sizes))
    explode = [0.05 if i == max_idx else 0 for i in range(len(sizes))]

    plt.pie(
        sizes,
        labels=labels,
        explode=explode,
        autopct='%1.1f%%',
        startangle=90,
        colors=plt.cm.Set3.colors[:len(labels)]
    )
    plt.title(title, fontsize=14)
    plt.axis('equal')
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()


def plot_multi_line_chart(
    x_data: list,
    y_data_dict: dict,
    title: str,
    xlabel: str,
    ylabel: str,
    output_path: str
):
    """绘制多条折线图"""
    plt.figure(figsize=(12, 6))

    for label, y_data in y_data_dict.items():
        plt.plot(x_data, y_data, marker='o', label=label, linewidth=2)

    plt.title(title, fontsize=14)
    plt.xlabel(xlabel, fontsize=12)
    plt.ylabel(ylabel, fontsize=12)
    plt.legend(loc='best')
    plt.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.savefig(output_path, dpi=150)
    plt.close()
```

### pyecharts 交互式图表

pyecharts 可以生成交互式的 HTML 图表：

```python
from pyecharts.charts import Bar, Line, Pie, WordCloud as PyechartsWordCloud
from pyecharts import options as opts
from pyecharts.globals import ThemeType

def create_bar_chart(
    categories: list,
    values: list,
    title: str,
    output_path: str
):
    """创建交互式柱状图"""
    bar = (
        Bar(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
        .add_xaxis(categories)
        .add_yaxis("数量", values)
        .set_global_opts(
            title_opts=opts.TitleOpts(title=title),
            toolbox_opts=opts.ToolboxOpts(is_show=True),
            datazoom_opts=opts.DataZoomOpts(is_show=True)
        )
    )
    bar.render(output_path)
    return output_path


def create_line_chart(
    x_data: list,
    y_data_dict: dict,
    title: str,
    output_path: str
):
    """创建交互式折线图"""
    line = Line(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
    line.add_xaxis(x_data)

    for name, y_data in y_data_dict.items():
        line.add_yaxis(
            name,
            y_data,
            is_smooth=True,
            markpoint_opts=opts.MarkPointOpts(
                data=[
                    opts.MarkPointItem(type_="max", name="最大值"),
                    opts.MarkPointItem(type_="min", name="最小值"),
                ]
            ),
            markline_opts=opts.MarkLineOpts(
                data=[opts.MarkLineItem(type_="average", name="平均值")]
            )
        )

    line.set_global_opts(
        title_opts=opts.TitleOpts(title=title),
        tooltip_opts=opts.TooltipOpts(trigger="axis"),
        toolbox_opts=opts.ToolboxOpts(is_show=True),
        legend_opts=opts.LegendOpts(is_show=True)
    )
    line.render(output_path)
    return output_path


def create_pie_chart(
    data: list,
    title: str,
    output_path: str
):
    """
    创建交互式饼图

    Args:
        data: [(name, value), ...] 格式的数据
        title: 图表标题
        output_path: 输出路径
    """
    pie = (
        Pie(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
        .add(
            "",
            data,
            radius=["30%", "70%"],
            rosetype="radius"
        )
        .set_global_opts(
            title_opts=opts.TitleOpts(title=title),
            legend_opts=opts.LegendOpts(
                orient="vertical",
                pos_top="15%",
                pos_left="2%"
            )
        )
        .set_series_opts(
            label_opts=opts.LabelOpts(formatter="{b}: {d}%")
        )
    )
    pie.render(output_path)
    return output_path


def create_wordcloud_chart(
    words: list,
    title: str,
    output_path: str
):
    """
    创建交互式词云

    Args:
        words: [(word, count), ...] 格式的数据
        title: 图表标题
        output_path: 输出路径
    """
    wc = (
        PyechartsWordCloud(init_opts=opts.InitOpts(theme=ThemeType.LIGHT))
        .add(
            "",
            words,
            word_size_range=[20, 100],
            shape="circle"
        )
        .set_global_opts(
            title_opts=opts.TitleOpts(title=title),
            toolbox_opts=opts.ToolboxOpts(is_show=True)
        )
    )
    wc.render(output_path)
    return output_path
```

## 10.5 数据分析报告生成

### Markdown 报告模板

自动生成 Markdown 格式的分析报告：

```python
from datetime import datetime
from typing import Dict, List, Any

class ReportGenerator:
    """数据分析报告生成器"""

    def __init__(self, title: str, author: str = "数据分析团队"):
        self.title = title
        self.author = author
        self.sections = []
        self.images = []

    def add_section(self, title: str, content: str):
        """添加章节"""
        self.sections.append({
            "title": title,
            "content": content
        })

    def add_image(self, path: str, caption: str):
        """添加图片"""
        self.images.append({
            "path": path,
            "caption": caption
        })

    def add_table(self, headers: List[str], rows: List[List[Any]], title: str = ""):
        """添加表格"""
        content = ""
        if title:
            content += f"**{title}**\n\n"

        # 表头
        content += "| " + " | ".join(headers) + " |\n"
        content += "| " + " | ".join(["---"] * len(headers)) + " |\n"

        # 数据行
        for row in rows:
            content += "| " + " | ".join(str(cell) for cell in row) + " |\n"

        self.sections.append({
            "title": "",
            "content": content
        })

    def add_summary(self, metrics: Dict[str, Any]):
        """添加数据摘要"""
        content = "| 指标 | 数值 |\n| --- | --- |\n"
        for key, value in metrics.items():
            content += f"| {key} | {value} |\n"

        self.sections.append({
            "title": "数据概览",
            "content": content
        })

    def generate(self, output_path: str) -> str:
        """生成报告"""
        report = []

        # 标题
        report.append(f"# {self.title}")
        report.append("")

        # 元信息
        report.append(f"> 生成时间：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append(f"> 作者：{self.author}")
        report.append("")
        report.append("---")
        report.append("")

        # 目录
        report.append("## 目录")
        report.append("")
        for i, section in enumerate(self.sections, 1):
            if section["title"]:
                report.append(f"{i}. [{section['title']}](#{section['title'].lower().replace(' ', '-')})")
        report.append("")
        report.append("---")
        report.append("")

        # 内容
        for section in self.sections:
            if section["title"]:
                report.append(f"## {section['title']}")
                report.append("")
            report.append(section["content"])
            report.append("")

        # 图表
        if self.images:
            report.append("## 图表")
            report.append("")
            for img in self.images:
                report.append(f"### {img['caption']}")
                report.append("")
                report.append(f"![{img['caption']}]({img['path']})")
                report.append("")

        # 写入文件
        content = "\n".join(report)
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(content)

        return output_path
```

### 完整分析流程示例

```python
import pandas as pd
from typing import List, Dict

class DataAnalyzer:
    """数据分析器"""

    def __init__(self, data: List[Dict]):
        self.df = pd.DataFrame(data)
        self.report = ReportGenerator("数据分析报告")

    def basic_statistics(self) -> Dict:
        """基础统计"""
        stats = {
            "总记录数": len(self.df),
            "时间范围": f"{self.df['date'].min()} ~ {self.df['date'].max()}" if 'date' in self.df else "N/A",
        }

        # 数值列统计
        numeric_cols = self.df.select_dtypes(include=['number']).columns
        for col in numeric_cols:
            stats[f"{col}_总计"] = self.df[col].sum()
            stats[f"{col}_平均"] = round(self.df[col].mean(), 2)
            stats[f"{col}_最大"] = self.df[col].max()
            stats[f"{col}_最小"] = self.df[col].min()

        return stats

    def category_analysis(self, category_col: str, value_col: str) -> pd.DataFrame:
        """分类分析"""
        return self.df.groupby(category_col)[value_col].agg([
            'count', 'sum', 'mean', 'max', 'min'
        ]).round(2)

    def time_series_analysis(self, date_col: str, value_col: str, freq: str = 'D') -> pd.DataFrame:
        """时间序列分析"""
        df_ts = self.df.copy()
        df_ts[date_col] = pd.to_datetime(df_ts[date_col])
        df_ts.set_index(date_col, inplace=True)

        return df_ts.resample(freq)[value_col].agg(['sum', 'mean', 'count']).round(2)

    def generate_report(self, output_dir: str) -> str:
        """生成完整分析报告"""
        import os
        os.makedirs(output_dir, exist_ok=True)

        # 1. 基础统计
        stats = self.basic_statistics()
        self.report.add_summary(stats)

        # 2. 添加描述性文字
        self.report.add_section(
            "分析说明",
            f"本报告对 {len(self.df)} 条数据进行了分析，"
            f"包含 {len(self.df.columns)} 个字段。"
        )

        # 3. 生成图表（如果有相应字段）
        numeric_cols = self.df.select_dtypes(include=['number']).columns.tolist()
        if numeric_cols:
            # 柱状图
            col = numeric_cols[0]
            if len(self.df) <= 20:
                bar_path = os.path.join(output_dir, "bar_chart.png")
                plot_bar_chart(
                    self.df.index.tolist() if self.df.index.dtype != 'int64' else list(range(len(self.df))),
                    self.df[col].tolist(),
                    f"{col} 分布",
                    "索引",
                    col,
                    bar_path
                )
                self.report.add_image(bar_path, f"{col} 分布柱状图")

        # 4. 生成报告
        report_path = os.path.join(output_dir, "report.md")
        return self.report.generate(report_path)
```

## 10.6 实战案例：社交媒体评论分析

让我们综合运用本章所学，对爬取的社交媒体评论数据进行完整分析：

```python
"""
社交媒体评论数据分析
"""
import os
import json
from datetime import datetime
from typing import List, Dict
from collections import Counter

import pandas as pd
import jieba
from wordcloud import WordCloud
import matplotlib.pyplot as plt
import matplotlib
matplotlib.rcParams['font.sans-serif'] = ['SimHei', 'Arial Unicode MS']
matplotlib.rcParams['axes.unicode_minus'] = False


class CommentAnalyzer:
    """评论数据分析器"""

    STOPWORDS = {
        '的', '是', '在', '了', '和', '与', '或', '有', '个', '人',
        '这', '那', '就', '都', '也', '为', '对', '到', '从', '把',
        '被', '让', '给', '向', '往', '于', '及', '以', '等', '不',
        '很', '会', '能', '可', '要', '我', '你', '他', '她', '它',
        '啊', '吧', '呢', '呀', '哦', '嗯', '哈', '嘿',
    }

    def __init__(self, comments: List[Dict], output_dir: str = "./analysis_output"):
        """
        Args:
            comments: 评论数据列表，每条评论包含 content, user, time, likes 等字段
            output_dir: 输出目录
        """
        self.comments = comments
        self.df = pd.DataFrame(comments)
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)

    def analyze_basic_stats(self) -> Dict:
        """基础统计分析"""
        stats = {
            "total_comments": len(self.df),
            "unique_users": self.df['user'].nunique() if 'user' in self.df else 0,
            "total_likes": self.df['likes'].sum() if 'likes' in self.df else 0,
            "avg_likes": round(self.df['likes'].mean(), 2) if 'likes' in self.df else 0,
            "avg_length": round(self.df['content'].str.len().mean(), 2),
        }

        # 时间分析
        if 'time' in self.df:
            self.df['time'] = pd.to_datetime(self.df['time'], errors='coerce')
            valid_times = self.df['time'].dropna()
            if len(valid_times) > 0:
                stats["time_range"] = f"{valid_times.min()} ~ {valid_times.max()}"

        return stats

    def analyze_word_frequency(self, top_n: int = 50) -> List[tuple]:
        """词频分析"""
        all_words = []

        for content in self.df['content']:
            words = jieba.lcut(str(content))
            # 过滤停用词和单字
            words = [
                w for w in words
                if w not in self.STOPWORDS and len(w) > 1
            ]
            all_words.extend(words)

        word_freq = Counter(all_words)
        return word_freq.most_common(top_n)

    def generate_wordcloud(self, font_path: str = None) -> str:
        """生成词云"""
        word_freq = self.analyze_word_frequency(200)

        # 转换为空格分隔的文本
        text = ' '.join([word for word, _ in word_freq for _ in range(word_freq[0][1])])

        # 直接使用词频
        freq_dict = dict(word_freq)

        wc = WordCloud(
            width=1200,
            height=800,
            background_color='white',
            font_path=font_path,
            max_words=200,
            max_font_size=150,
            random_state=42
        )

        wc.generate_from_frequencies(freq_dict)

        output_path = os.path.join(self.output_dir, "wordcloud.png")
        wc.to_file(output_path)

        return output_path

    def analyze_time_distribution(self) -> str:
        """时间分布分析"""
        if 'time' not in self.df:
            return None

        df = self.df.copy()
        df['time'] = pd.to_datetime(df['time'], errors='coerce')
        df = df.dropna(subset=['time'])

        if len(df) == 0:
            return None

        # 按小时统计
        df['hour'] = df['time'].dt.hour
        hour_dist = df.groupby('hour').size()

        # 绘图
        plt.figure(figsize=(12, 6))
        plt.bar(hour_dist.index, hour_dist.values, color='steelblue')
        plt.title('评论时间分布（按小时）', fontsize=14)
        plt.xlabel('小时', fontsize=12)
        plt.ylabel('评论数', fontsize=12)
        plt.xticks(range(0, 24))
        plt.grid(axis='y', alpha=0.3)
        plt.tight_layout()

        output_path = os.path.join(self.output_dir, "time_distribution.png")
        plt.savefig(output_path, dpi=150)
        plt.close()

        return output_path

    def analyze_user_activity(self, top_n: int = 10) -> str:
        """用户活跃度分析"""
        if 'user' not in self.df:
            return None

        user_counts = self.df['user'].value_counts().head(top_n)

        plt.figure(figsize=(12, 6))
        plt.barh(range(len(user_counts)), user_counts.values, color='steelblue')
        plt.yticks(range(len(user_counts)), user_counts.index)
        plt.title(f'评论最多的 {top_n} 位用户', fontsize=14)
        plt.xlabel('评论数', fontsize=12)
        plt.ylabel('用户', fontsize=12)
        plt.gca().invert_yaxis()
        plt.tight_layout()

        output_path = os.path.join(self.output_dir, "user_activity.png")
        plt.savefig(output_path, dpi=150)
        plt.close()

        return output_path

    def generate_report(self, font_path: str = None) -> str:
        """生成完整分析报告"""
        report_lines = []

        # 标题
        report_lines.append("# 社交媒体评论分析报告")
        report_lines.append("")
        report_lines.append(f"> 生成时间：{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report_lines.append("")
        report_lines.append("---")
        report_lines.append("")

        # 基础统计
        stats = self.analyze_basic_stats()
        report_lines.append("## 1. 基础统计")
        report_lines.append("")
        report_lines.append("| 指标 | 数值 |")
        report_lines.append("| --- | --- |")
        report_lines.append(f"| 评论总数 | {stats['total_comments']} |")
        report_lines.append(f"| 独立用户数 | {stats['unique_users']} |")
        report_lines.append(f"| 点赞总数 | {stats['total_likes']} |")
        report_lines.append(f"| 平均点赞数 | {stats['avg_likes']} |")
        report_lines.append(f"| 平均评论长度 | {stats['avg_length']} 字 |")
        if 'time_range' in stats:
            report_lines.append(f"| 时间范围 | {stats['time_range']} |")
        report_lines.append("")

        # 词频分析
        report_lines.append("## 2. 热门词汇 TOP 20")
        report_lines.append("")
        word_freq = self.analyze_word_frequency(20)
        report_lines.append("| 排名 | 词汇 | 出现次数 |")
        report_lines.append("| --- | --- | --- |")
        for i, (word, count) in enumerate(word_freq, 1):
            report_lines.append(f"| {i} | {word} | {count} |")
        report_lines.append("")

        # 生成图表
        report_lines.append("## 3. 可视化图表")
        report_lines.append("")

        # 词云
        wordcloud_path = self.generate_wordcloud(font_path)
        report_lines.append("### 3.1 词云图")
        report_lines.append("")
        report_lines.append(f"![词云图]({os.path.basename(wordcloud_path)})")
        report_lines.append("")

        # 时间分布
        time_path = self.analyze_time_distribution()
        if time_path:
            report_lines.append("### 3.2 评论时间分布")
            report_lines.append("")
            report_lines.append(f"![时间分布]({os.path.basename(time_path)})")
            report_lines.append("")

        # 用户活跃度
        user_path = self.analyze_user_activity()
        if user_path:
            report_lines.append("### 3.3 用户活跃度")
            report_lines.append("")
            report_lines.append(f"![用户活跃度]({os.path.basename(user_path)})")
            report_lines.append("")

        # 写入报告
        report_content = "\n".join(report_lines)
        report_path = os.path.join(self.output_dir, "analysis_report.md")
        with open(report_path, 'w', encoding='utf-8') as f:
            f.write(report_content)

        print(f"分析报告已生成: {report_path}")
        return report_path


def demo():
    """演示分析功能"""
    # 模拟评论数据
    comments = [
        {"content": "Python真的很好学，推荐这个教程！", "user": "user1", "time": "2024-01-15 10:30:00", "likes": 15},
        {"content": "爬虫入门很有用，学到了很多知识", "user": "user2", "time": "2024-01-15 11:20:00", "likes": 8},
        {"content": "数据分析这章讲得很详细，点赞", "user": "user3", "time": "2024-01-15 14:45:00", "likes": 12},
        {"content": "希望能出更多进阶内容，继续学习Python", "user": "user1", "time": "2024-01-15 16:00:00", "likes": 5},
        {"content": "词云效果很酷，学会了！", "user": "user4", "time": "2024-01-15 18:30:00", "likes": 20},
        {"content": "教程质量很高，适合入门学习", "user": "user5", "time": "2024-01-15 20:15:00", "likes": 10},
        {"content": "Python数据分析真的很强大", "user": "user6", "time": "2024-01-16 09:00:00", "likes": 7},
        {"content": "爬虫技术学起来很有趣", "user": "user7", "time": "2024-01-16 10:30:00", "likes": 9},
    ]

    # 创建分析器
    analyzer = CommentAnalyzer(comments, "./demo_output")

    # 生成报告
    report_path = analyzer.generate_report()
    print(f"报告已保存到: {report_path}")


if __name__ == "__main__":
    demo()
```

## 本章小结

本章我们学习了数据分析与可视化的核心技术：

1. **pandas 数据分析**
   - DataFrame 是数据分析的核心数据结构
   - groupby 实现分组聚合统计
   - pivot_table 进行多维分析
   - 时间序列支持滚动统计和重采样

2. **词云生成**
   - jieba 实现中文分词
   - 停用词过滤提升分析质量
   - wordcloud 库生成静态词云
   - 支持自定义形状和颜色

3. **数据可视化**
   - matplotlib 生成静态图表
   - pyecharts 生成交互式图表
   - 选择合适的图表类型展示数据

4. **自动化报告**
   - Markdown 格式便于阅读和分享
   - 模板化生成提高效率
   - 图表嵌入增强可读性

**关键要点：**
- 数据分析的目标是发现洞察，而非展示技术
- 选择合适的可视化方式，让数据"说话"
- 自动化报告生成可以大大提高效率
- 中文分析需要注意字体和编码问题

---

## 下一章预告

在最后一章「进阶综合实战项目」中，我们将综合运用整个进阶教程所学的所有技术，实现一个完整的社交媒体数据采集与分析工具。该项目将包含：

- 多种登录方式支持
- 反检测浏览器自动化
- 代理 IP 轮换
- 数据清洗和存储
- 词云和图表分析

敬请期待！
