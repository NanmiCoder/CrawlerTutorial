# 07_ç™»å½•è®¤è¯ï¼šæ‰«ç ä¸çŸ­ä¿¡ç™»å½•å®ç°

ä¸Šä¸€ç« æˆ‘ä»¬å­¦ä¹ äº† Cookie å’Œ Session çš„åŸºç¡€ç®¡ç†ï¼Œæœ¬ç« å°†æ·±å…¥æ¢è®¨æ›´å¤æ‚çš„ç™»å½•åœºæ™¯â€”â€”æ‰«ç ç™»å½•å’ŒçŸ­ä¿¡éªŒè¯ç ç™»å½•ã€‚è¿™äº›ç™»å½•æ–¹å¼åœ¨ç¤¾äº¤åª’ä½“ã€ç”µå•†ç­‰å¹³å°ä¸­å¹¿æ³›ä½¿ç”¨ï¼Œä¹Ÿæ˜¯ MediaCrawler ç­‰é¡¹ç›®çš„æ ¸å¿ƒæŠ€æœ¯ä¹‹ä¸€ã€‚

## ä¸€ã€æ‰«ç ç™»å½•åŸç†

### 1.1 æ‰«ç ç™»å½•æµç¨‹

æ‰«ç ç™»å½•æ˜¯ä¸€ç§å®‰å…¨ä¾¿æ·çš„è®¤è¯æ–¹å¼ï¼Œå…¶å·¥ä½œæµç¨‹å¦‚ä¸‹ï¼š

```mermaid
sequenceDiagram
    participant PC as PCæµè§ˆå™¨
    participant Server as æœåŠ¡å™¨
    participant APP as æ‰‹æœºAPP

    PC->>Server: 1. è¯·æ±‚äºŒç»´ç 
    Server-->>PC: 2. è¿”å›äºŒç»´ç +UUID

    loop è½®è¯¢ç™»å½•çŠ¶æ€
        PC->>Server: 3. æŸ¥è¯¢çŠ¶æ€
        Server-->>PC: çŠ¶æ€: å¾…æ‰«æ
    end

    APP->>Server: 4. ç”¨æˆ·æ‰«ç 
    Server-->>PC: 5. çŠ¶æ€: å·²æ‰«æ

    APP->>Server: 6. ç”¨æˆ·ç¡®è®¤
    Server-->>PC: 7. è¿”å›ç™»å½•å‡­è¯(Cookie)

    Note over PC: 8. ç™»å½•æˆåŠŸ!
```

### 1.2 å…³é”®æŠ€æœ¯ç‚¹

1. **äºŒç»´ç ç”Ÿæˆ**ï¼šæœåŠ¡å™¨ç”Ÿæˆå”¯ä¸€ UUIDï¼Œç¼–ç åˆ°äºŒç»´ç ä¸­
2. **çŠ¶æ€è½®è¯¢**ï¼šPC ç«¯å®šæ—¶æŸ¥è¯¢ç™»å½•çŠ¶æ€ï¼ˆé•¿è½®è¯¢æˆ– WebSocketï¼‰
3. **çŠ¶æ€æµè½¬**ï¼šå¾…æ‰«æ â†’ å·²æ‰«æ â†’ å·²ç¡®è®¤ â†’ å·²è¿‡æœŸ
4. **å‡­è¯ä¸‹å‘**ï¼šç™»å½•æˆåŠŸåé€šè¿‡ Cookie æˆ– Token è¿”å›å‡­è¯

### 1.3 å¸¸è§æ‰«ç ç™»å½•çŠ¶æ€

```python
from enum import Enum

class QRCodeStatus(Enum):
    """äºŒç»´ç çŠ¶æ€æšä¸¾"""
    WAITING = "waiting"      # ç­‰å¾…æ‰«æ
    SCANNED = "scanned"      # å·²æ‰«æï¼Œç­‰å¾…ç¡®è®¤
    CONFIRMED = "confirmed"  # å·²ç¡®è®¤ç™»å½•
    EXPIRED = "expired"      # äºŒç»´ç å·²è¿‡æœŸ
    CANCELED = "canceled"    # ç”¨æˆ·å–æ¶ˆ
```

## äºŒã€Playwright å®ç°æ‰«ç ç™»å½•

### 2.1 åŸºç¡€æ¡†æ¶

```python
import asyncio
from playwright.async_api import async_playwright, Page, BrowserContext
from typing import Optional, Callable, Awaitable
from loguru import logger
from enum import Enum

class QRCodeLoginBase:
    """æ‰«ç ç™»å½•åŸºç¡€ç±»"""

    def __init__(
        self,
        timeout: int = 120,
        poll_interval: float = 2.0,
        on_status_change: Optional[Callable[[str], Awaitable[None]]] = None
    ):
        """
        Args:
            timeout: ç™»å½•è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            poll_interval: çŠ¶æ€è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
            on_status_change: çŠ¶æ€å˜åŒ–å›è°ƒ
        """
        self.timeout = timeout
        self.poll_interval = poll_interval
        self.on_status_change = on_status_change

        self._page: Optional[Page] = None
        self._context: Optional[BrowserContext] = None
        self._current_status: Optional[str] = None

    async def _notify_status_change(self, status: str):
        """é€šçŸ¥çŠ¶æ€å˜åŒ–"""
        if status != self._current_status:
            self._current_status = status
            logger.info(f"ç™»å½•çŠ¶æ€å˜åŒ–: {status}")
            if self.on_status_change:
                await self.on_status_change(status)

    async def get_qrcode_image(self) -> bytes:
        """è·å–äºŒç»´ç å›¾ç‰‡ï¼Œå­ç±»å®ç°"""
        raise NotImplementedError

    async def check_login_status(self) -> str:
        """æ£€æŸ¥ç™»å½•çŠ¶æ€ï¼Œå­ç±»å®ç°"""
        raise NotImplementedError

    async def extract_cookies(self) -> list:
        """æå–ç™»å½•åçš„ Cookie"""
        if self._context:
            return await self._context.cookies()
        return []
```

### 2.2 å®Œæ•´æ‰«ç ç™»å½•å®ç°

ä»¥ä¸‹æ˜¯ä¸€ä¸ªé€šç”¨çš„æ‰«ç ç™»å½•å®ç°ç¤ºä¾‹ï¼š

```python
import asyncio
import base64
from pathlib import Path
from playwright.async_api import async_playwright, Page, BrowserContext
from typing import Optional, Callable, Awaitable
from loguru import logger

class QRCodeLogin:
    """é€šç”¨æ‰«ç ç™»å½•å®ç°"""

    def __init__(
        self,
        login_url: str,
        qrcode_selector: str,
        success_url_pattern: str,
        timeout: int = 120,
        poll_interval: float = 2.0
    ):
        """
        Args:
            login_url: ç™»å½•é¡µé¢ URL
            qrcode_selector: äºŒç»´ç å…ƒç´ é€‰æ‹©å™¨
            success_url_pattern: ç™»å½•æˆåŠŸåçš„ URL ç‰¹å¾
            timeout: è¶…æ—¶æ—¶é—´
            poll_interval: è½®è¯¢é—´éš”
        """
        self.login_url = login_url
        self.qrcode_selector = qrcode_selector
        self.success_url_pattern = success_url_pattern
        self.timeout = timeout
        self.poll_interval = poll_interval

        self._browser = None
        self._context = None
        self._page = None

    async def start(self, playwright, headless: bool = False):
        """å¯åŠ¨æµè§ˆå™¨"""
        self._browser = await playwright.chromium.launch(headless=headless)
        self._context = await self._browser.new_context()
        self._page = await self._context.new_page()
        logger.info("æµè§ˆå™¨å·²å¯åŠ¨")

    async def close(self):
        """å…³é—­æµè§ˆå™¨"""
        if self._browser:
            await self._browser.close()
        logger.info("æµè§ˆå™¨å·²å…³é—­")

    async def navigate_to_login(self):
        """å¯¼èˆªåˆ°ç™»å½•é¡µé¢"""
        await self._page.goto(self.login_url, wait_until="networkidle")
        logger.info(f"å·²æ‰“å¼€ç™»å½•é¡µé¢: {self.login_url}")

    async def save_qrcode(self, filepath: str = "qrcode.png"):
        """ä¿å­˜äºŒç»´ç å›¾ç‰‡"""
        # ç­‰å¾…äºŒç»´ç å‡ºç°
        await self._page.wait_for_selector(self.qrcode_selector, timeout=10000)

        # æˆªå–äºŒç»´ç 
        qrcode_element = self._page.locator(self.qrcode_selector)
        await qrcode_element.screenshot(path=filepath)
        logger.info(f"äºŒç»´ç å·²ä¿å­˜: {filepath}")
        return filepath

    async def wait_for_login(
        self,
        on_qrcode_ready: Optional[Callable[[str], Awaitable[None]]] = None
    ) -> bool:
        """
        ç­‰å¾…ç”¨æˆ·æ‰«ç ç™»å½•

        Args:
            on_qrcode_ready: äºŒç»´ç å‡†å¤‡å¥½åçš„å›è°ƒ

        Returns:
            æ˜¯å¦ç™»å½•æˆåŠŸ
        """
        # ä¿å­˜äºŒç»´ç 
        qrcode_path = await self.save_qrcode()

        # é€šçŸ¥äºŒç»´ç å·²å‡†å¤‡å¥½
        if on_qrcode_ready:
            await on_qrcode_ready(qrcode_path)

        # ç­‰å¾…ç™»å½•æˆåŠŸï¼ˆURL å˜åŒ–æˆ–ç‰¹å®šå…ƒç´ å‡ºç°ï¼‰
        try:
            await self._page.wait_for_url(
                f"**{self.success_url_pattern}**",
                timeout=self.timeout * 1000
            )
            logger.info("ç™»å½•æˆåŠŸï¼")
            return True
        except Exception as e:
            logger.warning(f"ç™»å½•è¶…æ—¶æˆ–å¤±è´¥: {e}")
            return False

    async def get_cookies(self) -> list:
        """è·å–ç™»å½•åçš„ Cookie"""
        return await self._context.cookies()

    async def login(
        self,
        on_qrcode_ready: Optional[Callable[[str], Awaitable[None]]] = None
    ) -> Optional[list]:
        """
        æ‰§è¡Œå®Œæ•´çš„æ‰«ç ç™»å½•æµç¨‹

        Returns:
            æˆåŠŸè¿”å› Cookie åˆ—è¡¨ï¼Œå¤±è´¥è¿”å› None
        """
        await self.navigate_to_login()
        success = await self.wait_for_login(on_qrcode_ready)

        if success:
            cookies = await self.get_cookies()
            logger.info(f"è·å–åˆ° {len(cookies)} ä¸ª Cookie")
            return cookies
        return None
```

### 2.3 ç»ˆç«¯æ˜¾ç¤ºäºŒç»´ç 

ä¸ºäº†åœ¨æ— å¤´æ¨¡å¼ä¸‹ä¹Ÿèƒ½æ‰«ç ï¼Œå¯ä»¥åœ¨ç»ˆç«¯æ˜¾ç¤ºäºŒç»´ç ï¼š

```python
try:
    import qrcode
    HAS_QRCODE = True
except ImportError:
    HAS_QRCODE = False

def display_qrcode_in_terminal(data: str):
    """åœ¨ç»ˆç«¯æ˜¾ç¤ºäºŒç»´ç """
    if not HAS_QRCODE:
        print("æç¤º: å®‰è£… qrcode åº“å¯åœ¨ç»ˆç«¯æ˜¾ç¤ºäºŒç»´ç : pip install qrcode")
        return

    qr = qrcode.QRCode(
        version=1,
        error_correction=qrcode.constants.ERROR_CORRECT_L,
        box_size=1,
        border=1
    )
    qr.add_data(data)
    qr.make(fit=True)

    # ä½¿ç”¨å­—ç¬¦ç»˜åˆ¶
    qr.print_ascii(invert=True)

def display_qrcode_image_in_terminal(image_path: str):
    """
    å°†å›¾ç‰‡äºŒç»´ç è½¬æ¢ä¸ºç»ˆç«¯å¯æ˜¾ç¤ºçš„æ–‡æœ¬
    éœ€è¦å®‰è£…: pip install pillow
    """
    try:
        from PIL import Image

        img = Image.open(image_path)
        img = img.convert('L')  # è½¬ä¸ºç°åº¦

        # ç¼©å°å›¾ç‰‡
        width = 60
        ratio = width / img.width
        height = int(img.height * ratio * 0.5)  # 0.5 è¡¥å¿ç»ˆç«¯å­—ç¬¦é«˜å®½æ¯”
        img = img.resize((width, height))

        # è½¬æ¢ä¸º ASCII
        chars = " .:-=+*#%@"
        pixels = img.getdata()
        ascii_img = ""
        for i, pixel in enumerate(pixels):
            if i > 0 and i % width == 0:
                ascii_img += "\n"
            ascii_img += chars[pixel * len(chars) // 256]

        print(ascii_img)
    except ImportError:
        print(f"äºŒç»´ç å·²ä¿å­˜åˆ°: {image_path}")
```

## ä¸‰ã€çŸ­ä¿¡éªŒè¯ç ç™»å½•

### 3.1 çŸ­ä¿¡ç™»å½•æµç¨‹

```mermaid
sequenceDiagram
    participant User as ç”¨æˆ·
    participant Frontend as å‰ç«¯
    participant Server as æœåŠ¡å™¨

    User->>Frontend: 1. è¾“å…¥æ‰‹æœºå·
    Frontend->>Server: 2. è¯·æ±‚å‘é€éªŒè¯ç 
    Server-->>Frontend: 3. è¿”å›å‘é€ç»“æœ

    User->>Frontend: 4. è¾“å…¥éªŒè¯ç 
    Frontend->>Server: 5. æäº¤ç™»å½•è¯·æ±‚
    Server-->>Frontend: 6. è¿”å›ç™»å½•ç»“æœ+å‡­è¯

    Note over User,Server: ç™»å½•æˆåŠŸï¼Œè·å–Cookie
```

### 3.2 Playwright å®ç°çŸ­ä¿¡ç™»å½•

```python
import asyncio
from playwright.async_api import async_playwright, Page
from typing import Optional, Callable, Awaitable
from loguru import logger

class SMSLogin:
    """çŸ­ä¿¡éªŒè¯ç ç™»å½•"""

    def __init__(
        self,
        login_url: str,
        phone_input_selector: str,
        send_code_btn_selector: str,
        code_input_selector: str,
        submit_btn_selector: str,
        success_url_pattern: str
    ):
        """
        Args:
            login_url: ç™»å½•é¡µ URL
            phone_input_selector: æ‰‹æœºå·è¾“å…¥æ¡†é€‰æ‹©å™¨
            send_code_btn_selector: å‘é€éªŒè¯ç æŒ‰é’®é€‰æ‹©å™¨
            code_input_selector: éªŒè¯ç è¾“å…¥æ¡†é€‰æ‹©å™¨
            submit_btn_selector: ç™»å½•æŒ‰é’®é€‰æ‹©å™¨
            success_url_pattern: ç™»å½•æˆåŠŸ URL ç‰¹å¾
        """
        self.login_url = login_url
        self.phone_input_selector = phone_input_selector
        self.send_code_btn_selector = send_code_btn_selector
        self.code_input_selector = code_input_selector
        self.submit_btn_selector = submit_btn_selector
        self.success_url_pattern = success_url_pattern

        self._browser = None
        self._context = None
        self._page = None

    async def start(self, playwright, headless: bool = False):
        """å¯åŠ¨æµè§ˆå™¨"""
        self._browser = await playwright.chromium.launch(headless=headless)
        self._context = await self._browser.new_context()
        self._page = await self._context.new_page()

    async def close(self):
        """å…³é—­æµè§ˆå™¨"""
        if self._browser:
            await self._browser.close()

    async def input_phone(self, phone: str):
        """è¾“å…¥æ‰‹æœºå·"""
        await self._page.goto(self.login_url, wait_until="networkidle")
        await self._page.fill(self.phone_input_selector, phone)
        logger.info(f"å·²è¾“å…¥æ‰‹æœºå·: {phone[:3]}****{phone[-4:]}")

    async def send_verification_code(self) -> bool:
        """å‘é€éªŒè¯ç """
        try:
            await self._page.click(self.send_code_btn_selector)
            logger.info("éªŒè¯ç å‘é€è¯·æ±‚å·²æäº¤")
            # ç­‰å¾…ä¸€å°æ®µæ—¶é—´ç¡®ä¿è¯·æ±‚å‘å‡º
            await asyncio.sleep(1)
            return True
        except Exception as e:
            logger.error(f"å‘é€éªŒè¯ç å¤±è´¥: {e}")
            return False

    async def input_code_and_login(
        self,
        code: str,
        timeout: int = 30
    ) -> bool:
        """è¾“å…¥éªŒè¯ç å¹¶ç™»å½•"""
        try:
            await self._page.fill(self.code_input_selector, code)
            await self._page.click(self.submit_btn_selector)

            # ç­‰å¾…ç™»å½•æˆåŠŸ
            await self._page.wait_for_url(
                f"**{self.success_url_pattern}**",
                timeout=timeout * 1000
            )
            logger.info("ç™»å½•æˆåŠŸï¼")
            return True
        except Exception as e:
            logger.error(f"ç™»å½•å¤±è´¥: {e}")
            return False

    async def get_cookies(self) -> list:
        """è·å– Cookie"""
        return await self._context.cookies()

    async def login_with_manual_code(
        self,
        phone: str,
        get_code_callback: Callable[[], Awaitable[str]]
    ) -> Optional[list]:
        """
        ä½¿ç”¨æ‰‹åŠ¨è¾“å…¥éªŒè¯ç çš„æ–¹å¼ç™»å½•

        Args:
            phone: æ‰‹æœºå·
            get_code_callback: è·å–éªŒè¯ç çš„å›è°ƒï¼ˆå¦‚ç­‰å¾…ç”¨æˆ·è¾“å…¥ï¼‰

        Returns:
            æˆåŠŸè¿”å› Cookieï¼Œå¤±è´¥è¿”å› None
        """
        await self.input_phone(phone)
        await self.send_verification_code()

        # è·å–éªŒè¯ç ï¼ˆæ‰‹åŠ¨è¾“å…¥æˆ–ä»æ¥ç å¹³å°è·å–ï¼‰
        code = await get_code_callback()

        if await self.input_code_and_login(code):
            return await self.get_cookies()
        return None
```

### 3.3 éªŒè¯ç è·å–æ–¹å¼

```python
import asyncio

async def get_code_from_user() -> str:
    """ä»æ§åˆ¶å°è·å–ç”¨æˆ·è¾“å…¥çš„éªŒè¯ç """
    print("\nè¯·è¾“å…¥æ”¶åˆ°çš„éªŒè¯ç : ", end="", flush=True)
    # åœ¨å¼‚æ­¥ç¯å¢ƒä¸­ç­‰å¾…ç”¨æˆ·è¾“å…¥
    loop = asyncio.get_event_loop()
    code = await loop.run_in_executor(None, input)
    return code.strip()


class SMSCodeReceiver:
    """
    çŸ­ä¿¡æ¥ç å¹³å°æ¥å£ï¼ˆç¤ºæ„ï¼‰

    æ³¨æ„ï¼šå®é™…ä½¿ç”¨éœ€è¦æ¥å…¥å…·ä½“çš„æ¥ç å¹³å° API
    """

    def __init__(self, api_key: str, api_url: str):
        self.api_key = api_key
        self.api_url = api_url

    async def get_phone_number(self) -> str:
        """è·å–æ‰‹æœºå·"""
        # è°ƒç”¨æ¥ç å¹³å° API è·å–æ‰‹æœºå·
        raise NotImplementedError("éœ€è¦å®ç°å…·ä½“çš„æ¥ç å¹³å°æ¥å£")

    async def wait_for_code(self, phone: str, timeout: int = 60) -> Optional[str]:
        """ç­‰å¾…æ¥æ”¶éªŒè¯ç """
        # è½®è¯¢æ¥ç å¹³å°è·å–éªŒè¯ç 
        raise NotImplementedError("éœ€è¦å®ç°å…·ä½“çš„æ¥ç å¹³å°æ¥å£")

    async def release_phone(self, phone: str):
        """é‡Šæ”¾æ‰‹æœºå·"""
        raise NotImplementedError("éœ€è¦å®ç°å…·ä½“çš„æ¥ç å¹³å°æ¥å£")
```

## å››ã€ç™»å½•æ¨¡å—ç»Ÿä¸€å°è£…

### 4.1 ä½¿ç”¨å·¥å‚æ¨¡å¼

```python
from abc import ABC, abstractmethod
from typing import Optional, Callable, Awaitable
from enum import Enum

class LoginMethod(Enum):
    """ç™»å½•æ–¹å¼æšä¸¾"""
    QRCODE = "qrcode"           # æ‰«ç ç™»å½•
    SMS = "sms"                 # çŸ­ä¿¡éªŒè¯ç 
    PASSWORD = "password"       # è´¦å·å¯†ç 
    COOKIE = "cookie"           # Cookie æ³¨å…¥

class LoginResult:
    """ç™»å½•ç»“æœ"""

    def __init__(
        self,
        success: bool,
        cookies: list = None,
        error: str = None
    ):
        self.success = success
        self.cookies = cookies or []
        self.error = error

class BaseLogin(ABC):
    """ç™»å½•åŸºç±»"""

    @abstractmethod
    async def login(self) -> LoginResult:
        """æ‰§è¡Œç™»å½•"""
        pass

    @abstractmethod
    async def close(self):
        """æ¸…ç†èµ„æº"""
        pass

class LoginFactory:
    """ç™»å½•å·¥å‚"""

    _registry = {}

    @classmethod
    def register(cls, method: LoginMethod):
        """æ³¨å†Œç™»å½•å®ç°"""
        def decorator(login_class):
            cls._registry[method] = login_class
            return login_class
        return decorator

    @classmethod
    def create(
        cls,
        method: LoginMethod,
        **kwargs
    ) -> BaseLogin:
        """åˆ›å»ºç™»å½•å®ä¾‹"""
        if method not in cls._registry:
            raise ValueError(f"ä¸æ”¯æŒçš„ç™»å½•æ–¹å¼: {method}")
        return cls._registry[method](**kwargs)
```

### 4.2 æ³¨å†Œå…·ä½“å®ç°

```python
@LoginFactory.register(LoginMethod.COOKIE)
class CookieLogin(BaseLogin):
    """Cookie æ³¨å…¥ç™»å½•"""

    def __init__(self, cookies: list, check_url: str = None):
        self.cookies = cookies
        self.check_url = check_url

    async def login(self) -> LoginResult:
        """Cookie æ³¨å…¥ä¸éœ€è¦å®é™…ç™»å½•ï¼Œç›´æ¥è¿”å›"""
        return LoginResult(success=True, cookies=self.cookies)

    async def close(self):
        pass


@LoginFactory.register(LoginMethod.QRCODE)
class QRCodeLoginImpl(BaseLogin):
    """æ‰«ç ç™»å½•å®ç°"""

    def __init__(
        self,
        login_url: str,
        qrcode_selector: str,
        success_url_pattern: str,
        on_qrcode_ready: Callable[[str], Awaitable[None]] = None,
        **kwargs
    ):
        self.login_url = login_url
        self.qrcode_selector = qrcode_selector
        self.success_url_pattern = success_url_pattern
        self.on_qrcode_ready = on_qrcode_ready
        self._qrcode_login = None
        self._playwright = None

    async def login(self) -> LoginResult:
        from playwright.async_api import async_playwright

        self._playwright = await async_playwright().start()
        self._qrcode_login = QRCodeLogin(
            login_url=self.login_url,
            qrcode_selector=self.qrcode_selector,
            success_url_pattern=self.success_url_pattern
        )

        await self._qrcode_login.start(self._playwright, headless=False)

        try:
            cookies = await self._qrcode_login.login(self.on_qrcode_ready)
            if cookies:
                return LoginResult(success=True, cookies=cookies)
            return LoginResult(success=False, error="ç™»å½•è¶…æ—¶")
        except Exception as e:
            return LoginResult(success=False, error=str(e))

    async def close(self):
        if self._qrcode_login:
            await self._qrcode_login.close()
        if self._playwright:
            await self._playwright.stop()
```

### 4.3 ç»Ÿä¸€ç™»å½•ç®¡ç†å™¨

```python
import json
from pathlib import Path
from loguru import logger

class LoginManager:
    """ç»Ÿä¸€ç™»å½•ç®¡ç†å™¨"""

    def __init__(
        self,
        platform: str,
        cookie_path: str,
        preferred_method: LoginMethod = LoginMethod.COOKIE
    ):
        """
        Args:
            platform: å¹³å°åç§°
            cookie_path: Cookie å­˜å‚¨è·¯å¾„
            preferred_method: é¦–é€‰ç™»å½•æ–¹å¼
        """
        self.platform = platform
        self.cookie_path = Path(cookie_path)
        self.preferred_method = preferred_method
        self._cookies: list = []

    async def ensure_login(self, **login_kwargs) -> bool:
        """
        ç¡®ä¿å·²ç™»å½•

        ä¼˜å…ˆä½¿ç”¨å·²ä¿å­˜çš„ Cookieï¼Œå¦‚æœæ— æ•ˆåˆ™ä½¿ç”¨æŒ‡å®šæ–¹å¼ç™»å½•
        """
        # 1. å°è¯•åŠ è½½å·²ä¿å­˜çš„ Cookie
        if await self._try_load_cookies():
            logger.info(f"[{self.platform}] ä½¿ç”¨å·²ä¿å­˜çš„ Cookie")
            return True

        # 2. æ‰§è¡Œç™»å½•
        logger.info(f"[{self.platform}] å¼€å§‹ {self.preferred_method.value} ç™»å½•")
        login = LoginFactory.create(self.preferred_method, **login_kwargs)

        try:
            result = await login.login()
            if result.success:
                self._cookies = result.cookies
                await self._save_cookies()
                logger.info(f"[{self.platform}] ç™»å½•æˆåŠŸ")
                return True
            else:
                logger.error(f"[{self.platform}] ç™»å½•å¤±è´¥: {result.error}")
                return False
        finally:
            await login.close()

    async def _try_load_cookies(self) -> bool:
        """å°è¯•åŠ è½½ Cookie"""
        if not self.cookie_path.exists():
            return False

        try:
            with open(self.cookie_path, "r") as f:
                self._cookies = json.load(f)

            # TODO: éªŒè¯ Cookie æœ‰æ•ˆæ€§
            return len(self._cookies) > 0
        except Exception as e:
            logger.warning(f"åŠ è½½ Cookie å¤±è´¥: {e}")
            return False

    async def _save_cookies(self):
        """ä¿å­˜ Cookie"""
        self.cookie_path.parent.mkdir(parents=True, exist_ok=True)
        with open(self.cookie_path, "w") as f:
            json.dump(self._cookies, f, indent=2)
        logger.info(f"Cookie å·²ä¿å­˜: {self.cookie_path}")

    def get_cookies(self) -> list:
        """è·å– Cookie"""
        return self._cookies

    def get_cookies_dict(self) -> dict:
        """è·å–å­—å…¸æ ¼å¼çš„ Cookie"""
        return {c["name"]: c["value"] for c in self._cookies}
```

## äº”ã€å®æˆ˜ç¤ºä¾‹

### 5.1 å®Œæ•´çš„æ‰«ç ç™»å½•ç¤ºä¾‹

```python
import asyncio
from playwright.async_api import async_playwright
import json

async def qrcode_login_demo():
    """æ‰«ç ç™»å½•å®Œæ•´ç¤ºä¾‹"""

    # äºŒç»´ç å‡†å¤‡å¥½åçš„å›è°ƒ
    async def on_qrcode_ready(path: str):
        print(f"\n{'='*40}")
        print(f"è¯·ä½¿ç”¨æ‰‹æœºæ‰«æäºŒç»´ç : {path}")
        print(f"{'='*40}\n")
        # å¯ä»¥åœ¨è¿™é‡Œæ˜¾ç¤ºäºŒç»´ç åˆ°ç»ˆç«¯
        display_qrcode_image_in_terminal(path)

    async with async_playwright() as p:
        # åˆ›å»ºæ‰«ç ç™»å½•å®ä¾‹ï¼ˆä»¥ç¤ºä¾‹ç½‘ç«™ä¸ºä¾‹ï¼‰
        qr_login = QRCodeLogin(
            login_url="https://example.com/login",
            qrcode_selector="img.qrcode",  # äºŒç»´ç é€‰æ‹©å™¨
            success_url_pattern="/dashboard",
            timeout=120
        )

        await qr_login.start(p, headless=False)

        try:
            cookies = await qr_login.login(on_qrcode_ready)

            if cookies:
                # ä¿å­˜ Cookie
                with open("login_cookies.json", "w") as f:
                    json.dump(cookies, f, indent=2)
                print(f"ç™»å½•æˆåŠŸï¼è·å–åˆ° {len(cookies)} ä¸ª Cookie")
            else:
                print("ç™»å½•å¤±è´¥æˆ–è¶…æ—¶")
        finally:
            await qr_login.close()


if __name__ == "__main__":
    asyncio.run(qrcode_login_demo())
```

### 5.2 å¤šå¹³å°ç™»å½•ç®¡ç†

```python
async def multi_platform_demo():
    """å¤šå¹³å°ç™»å½•ç®¡ç†ç¤ºä¾‹"""

    # é…ç½®å¤šä¸ªå¹³å°
    platforms = {
        "platform_a": {
            "cookie_path": "data/platform_a_cookies.json",
            "login_url": "https://a.example.com/login",
            "qrcode_selector": "#qrcode-img",
            "success_url": "/home"
        },
        "platform_b": {
            "cookie_path": "data/platform_b_cookies.json",
            "login_url": "https://b.example.com/login",
            "qrcode_selector": ".login-qrcode",
            "success_url": "/dashboard"
        }
    }

    for name, config in platforms.items():
        print(f"\nå¤„ç†å¹³å°: {name}")

        manager = LoginManager(
            platform=name,
            cookie_path=config["cookie_path"],
            preferred_method=LoginMethod.QRCODE
        )

        # å®šä¹‰äºŒç»´ç å›è°ƒ
        async def on_qrcode(path: str):
            print(f"[{name}] è¯·æ‰«æäºŒç»´ç : {path}")

        success = await manager.ensure_login(
            login_url=config["login_url"],
            qrcode_selector=config["qrcode_selector"],
            success_url_pattern=config["success_url"],
            on_qrcode_ready=on_qrcode
        )

        if success:
            cookies = manager.get_cookies_dict()
            print(f"[{name}] ç™»å½•æˆåŠŸï¼ŒCookie æ•°é‡: {len(cookies)}")
```

## å…­ã€æœ€ä½³å®è·µ

### 6.1 å®‰å…¨å»ºè®®

1. **ä¸è¦é¢‘ç¹ç™»å½•**ï¼šé¢‘ç¹ç™»å½•å¯èƒ½è§¦å‘é£æ§
2. **ä¿æŠ¤ç™»å½•å‡­è¯**ï¼šCookie åº”åŠ å¯†å­˜å‚¨
3. **éµå®ˆæœåŠ¡æ¡æ¬¾**ï¼šäº†è§£å¹³å°çš„ä½¿ç”¨é™åˆ¶
4. **å¤„ç†æ•æ„Ÿä¿¡æ¯**ï¼šæ‰‹æœºå·ç­‰ä¿¡æ¯ä¸è¦ç¡¬ç¼–ç 

### 6.2 ç¨³å®šæ€§å»ºè®®

1. **è¶…æ—¶å¤„ç†**ï¼šè®¾ç½®åˆç†çš„è¶…æ—¶æ—¶é—´
2. **é‡è¯•æœºåˆ¶**ï¼šç™»å½•å¤±è´¥æ—¶é€‚å½“é‡è¯•
3. **çŠ¶æ€ç›‘æ§**ï¼šç›‘æ§ç™»å½•çŠ¶æ€ï¼ŒåŠæ—¶å‘ç°é—®é¢˜
4. **ä¼˜é›…é™çº§**ï¼šæä¾›å¤šç§ç™»å½•æ–¹å¼ä½œä¸ºå¤‡é€‰

### 6.3 ä»£ç ç»„ç»‡å»ºè®®

```
login/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ base.py           # åŸºç±»å®šä¹‰
â”œâ”€â”€ factory.py        # ç™»å½•å·¥å‚
â”œâ”€â”€ qrcode.py         # æ‰«ç ç™»å½•å®ç°
â”œâ”€â”€ sms.py            # çŸ­ä¿¡ç™»å½•å®ç°
â”œâ”€â”€ cookie.py         # Cookie ç™»å½•å®ç°
â””â”€â”€ manager.py        # ç»Ÿä¸€ç®¡ç†å™¨
```

## ä¸ƒã€Bç«™æ‰«ç ç™»å½•å®æˆ˜

æœ¬èŠ‚ä»¥ Bç«™ ä¸ºå®æˆ˜å¹³å°ï¼Œæ¼”ç¤ºå®Œæ•´çš„æ‰«ç ç™»å½•å®ç°ã€‚Bç«™ æ˜¯å›½å†…æœ€å¤§çš„äºŒæ¬¡å…ƒè§†é¢‘å¹³å°ï¼Œå…¶ç™»å½•ç³»ç»Ÿå…·æœ‰ä»£è¡¨æ€§ã€‚

### 7.1 Bç«™æ‰«ç ç™»å½•æµç¨‹åˆ†æ

Bç«™æ‰«ç ç™»å½•æ¶‰åŠä»¥ä¸‹APIï¼š

```mermaid
sequenceDiagram
    participant PC as PCæµè§ˆå™¨
    participant Server as Bç«™æœåŠ¡å™¨
    participant APP as Bç«™APP

    PC->>Server: 1. GET /qrcode/generate
    Server-->>PC: 2. è¿”å› qrcode_key + url

    Note over PC: ç”ŸæˆäºŒç»´ç å›¾ç‰‡

    loop è½®è¯¢ç™»å½•çŠ¶æ€ (é—´éš”2ç§’)
        PC->>Server: 3. GET /qrcode/poll?qrcode_key=xxx
        Server-->>PC: 4. è¿”å›çŠ¶æ€ç 
        Note right of Server: 86101=æœªæ‰«æ<br/>86090=å·²æ‰«æ<br/>86038=å·²è¿‡æœŸ<br/>0=å·²ç¡®è®¤
    end

    APP->>Server: 5. ç”¨æˆ·æ‰«ç 
    Server-->>PC: 6. çŠ¶æ€: 86090 å·²æ‰«æ

    APP->>Server: 7. ç”¨æˆ·ç¡®è®¤ç™»å½•
    Server-->>PC: 8. çŠ¶æ€: 0 + Set-Cookie

    Note over PC: 9. ç™»å½•æˆåŠŸï¼ä¿å­˜Cookie
```

### 7.2 Bç«™ç™»å½•çŠ¶æ€ç 

| çŠ¶æ€ç  | å«ä¹‰ | è¯´æ˜ |
|-------|------|------|
| 0 | æˆåŠŸ | ç™»å½•æˆåŠŸï¼Œå“åº”ä¸­åŒ…å«Cookie |
| 86101 | æœªæ‰«æ | ç­‰å¾…ç”¨æˆ·æ‰«æäºŒç»´ç  |
| 86090 | å·²æ‰«æ | ç”¨æˆ·å·²æ‰«æï¼Œç­‰å¾…ç¡®è®¤ |
| 86038 | å·²è¿‡æœŸ | äºŒç»´ç å·²è¿‡æœŸï¼Œéœ€é‡æ–°è·å– |

### 7.3 Bç«™æ‰«ç ç™»å½•å®Œæ•´å®ç°

```python
import asyncio
import httpx
import qrcode
from io import BytesIO
from dataclasses import dataclass
from typing import Optional, Callable, Awaitable
from enum import IntEnum
from loguru import logger


class BilibiliQRStatus(IntEnum):
    """Bç«™æ‰«ç çŠ¶æ€ç """
    SUCCESS = 0           # ç™»å½•æˆåŠŸ
    NOT_SCANNED = 86101   # æœªæ‰«æ
    SCANNED = 86090       # å·²æ‰«æï¼Œå¾…ç¡®è®¤
    EXPIRED = 86038       # å·²è¿‡æœŸ


@dataclass
class BilibiliCookies:
    """Bç«™Cookieæ•°æ®ç±»"""
    sessdata: str
    dede_user_id: str
    bili_jct: str
    buvid3: str = ""
    buvid4: str = ""
    sid: str = ""

    def to_dict(self) -> dict:
        """è½¬æ¢ä¸ºhttpxå¯ç”¨çš„å­—å…¸æ ¼å¼"""
        return {
            "SESSDATA": self.sessdata,
            "DedeUserID": self.dede_user_id,
            "bili_jct": self.bili_jct,
            "buvid3": self.buvid3,
            "buvid4": self.buvid4,
            "sid": self.sid,
        }


class BilibiliQRCodeLogin:
    """Bç«™æ‰«ç ç™»å½•å®ç°"""

    # Bç«™ç™»å½•ç›¸å…³API
    QRCODE_GENERATE_URL = "https://passport.bilibili.com/x/passport-login/web/qrcode/generate"
    QRCODE_POLL_URL = "https://passport.bilibili.com/x/passport-login/web/qrcode/poll"

    def __init__(
        self,
        timeout: int = 180,
        poll_interval: float = 2.0,
        on_status_change: Optional[Callable[[int, str], Awaitable[None]]] = None
    ):
        """
        Args:
            timeout: ç™»å½•è¶…æ—¶æ—¶é—´ï¼ˆç§’ï¼‰
            poll_interval: çŠ¶æ€è½®è¯¢é—´éš”ï¼ˆç§’ï¼‰
            on_status_change: çŠ¶æ€å˜åŒ–å›è°ƒ (status_code, message)
        """
        self.timeout = timeout
        self.poll_interval = poll_interval
        self.on_status_change = on_status_change

        self._client: Optional[httpx.AsyncClient] = None
        self._qrcode_key: str = ""
        self._current_status: int = -1

    async def __aenter__(self):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å…¥å£"""
        self._client = httpx.AsyncClient(
            headers={
                "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                              "AppleWebKit/537.36 (KHTML, like Gecko) "
                              "Chrome/120.0.0.0 Safari/537.36",
                "Referer": "https://www.bilibili.com/",
            }
        )
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """å¼‚æ­¥ä¸Šä¸‹æ–‡ç®¡ç†å™¨å‡ºå£"""
        if self._client:
            await self._client.aclose()

    async def _notify_status(self, code: int, message: str):
        """é€šçŸ¥çŠ¶æ€å˜åŒ–"""
        if code != self._current_status:
            self._current_status = code
            logger.info(f"Bç«™ç™»å½•çŠ¶æ€: {message} ({code})")
            if self.on_status_change:
                await self.on_status_change(code, message)

    async def generate_qrcode(self) -> tuple[str, bytes]:
        """
        ç”Ÿæˆç™»å½•äºŒç»´ç 

        Returns:
            (qrcode_url, qrcode_image_bytes)
        """
        resp = await self._client.get(self.QRCODE_GENERATE_URL)
        data = resp.json()

        if data["code"] != 0:
            raise Exception(f"è·å–äºŒç»´ç å¤±è´¥: {data['message']}")

        self._qrcode_key = data["data"]["qrcode_key"]
        qrcode_url = data["data"]["url"]

        # ç”ŸæˆäºŒç»´ç å›¾ç‰‡
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=10,
            border=2
        )
        qr.add_data(qrcode_url)
        qr.make(fit=True)

        img = qr.make_image(fill_color="black", back_color="white")
        buffer = BytesIO()
        img.save(buffer, format="PNG")

        logger.info("Bç«™ç™»å½•äºŒç»´ç å·²ç”Ÿæˆ")
        return qrcode_url, buffer.getvalue()

    def print_qrcode_to_terminal(self, url: str):
        """åœ¨ç»ˆç«¯æ‰“å°äºŒç»´ç """
        qr = qrcode.QRCode(
            version=1,
            error_correction=qrcode.constants.ERROR_CORRECT_L,
            box_size=1,
            border=1
        )
        qr.add_data(url)
        qr.make(fit=True)
        qr.print_ascii(invert=True)

    async def poll_status(self) -> tuple[int, Optional[BilibiliCookies]]:
        """
        è½®è¯¢ç™»å½•çŠ¶æ€

        Returns:
            (status_code, cookies_if_success)
        """
        resp = await self._client.get(
            self.QRCODE_POLL_URL,
            params={"qrcode_key": self._qrcode_key}
        )
        data = resp.json()

        code = data["data"]["code"]
        message = data["data"]["message"]

        await self._notify_status(code, message)

        if code == BilibiliQRStatus.SUCCESS:
            # ç™»å½•æˆåŠŸï¼Œä»å“åº”ä¸­æå–Cookie
            cookies = self._extract_cookies(resp)
            return code, cookies

        return code, None

    def _extract_cookies(self, resp: httpx.Response) -> BilibiliCookies:
        """ä»å“åº”ä¸­æå–Bç«™Cookie"""
        cookies = resp.cookies

        # åŒæ—¶ä»å“åº”ä½“è·å–refresh_tokenç­‰ä¿¡æ¯
        data = resp.json()["data"]

        return BilibiliCookies(
            sessdata=cookies.get("SESSDATA", ""),
            dede_user_id=cookies.get("DedeUserID", ""),
            bili_jct=cookies.get("bili_jct", ""),
            buvid3=cookies.get("buvid3", ""),
            buvid4=cookies.get("buvid4", ""),
            sid=cookies.get("sid", ""),
        )

    async def login(
        self,
        save_qrcode_path: str = "bilibili_qrcode.png",
        show_in_terminal: bool = True
    ) -> Optional[BilibiliCookies]:
        """
        æ‰§è¡Œå®Œæ•´çš„æ‰«ç ç™»å½•æµç¨‹

        Args:
            save_qrcode_path: äºŒç»´ç å›¾ç‰‡ä¿å­˜è·¯å¾„
            show_in_terminal: æ˜¯å¦åœ¨ç»ˆç«¯æ˜¾ç¤ºäºŒç»´ç 

        Returns:
            ç™»å½•æˆåŠŸè¿”å›Cookieï¼Œå¤±è´¥è¿”å›None
        """
        # 1. ç”ŸæˆäºŒç»´ç 
        url, image_bytes = await self.generate_qrcode()

        # ä¿å­˜äºŒç»´ç å›¾ç‰‡
        with open(save_qrcode_path, "wb") as f:
            f.write(image_bytes)
        logger.info(f"äºŒç»´ç å·²ä¿å­˜è‡³: {save_qrcode_path}")

        # åœ¨ç»ˆç«¯æ˜¾ç¤º
        if show_in_terminal:
            print("\nè¯·ä½¿ç”¨Bç«™APPæ‰«æä»¥ä¸‹äºŒç»´ç ç™»å½•:\n")
            self.print_qrcode_to_terminal(url)
            print(f"\näºŒç»´ç å›¾ç‰‡ä¹Ÿå·²ä¿å­˜è‡³: {save_qrcode_path}\n")

        # 2. è½®è¯¢ç™»å½•çŠ¶æ€
        start_time = asyncio.get_event_loop().time()

        while True:
            elapsed = asyncio.get_event_loop().time() - start_time
            if elapsed > self.timeout:
                logger.warning("ç™»å½•è¶…æ—¶")
                return None

            code, cookies = await self.poll_status()

            if code == BilibiliQRStatus.SUCCESS:
                logger.info("Bç«™ç™»å½•æˆåŠŸï¼")
                return cookies

            if code == BilibiliQRStatus.EXPIRED:
                logger.warning("äºŒç»´ç å·²è¿‡æœŸ")
                return None

            await asyncio.sleep(self.poll_interval)


async def bilibili_qrcode_login_demo():
    """Bç«™æ‰«ç ç™»å½•æ¼”ç¤º"""
    import json
    from pathlib import Path

    # çŠ¶æ€å˜åŒ–å›è°ƒ
    async def on_status(code: int, message: str):
        status_emoji = {
            BilibiliQRStatus.NOT_SCANNED: "â³",
            BilibiliQRStatus.SCANNED: "ğŸ“±",
            BilibiliQRStatus.SUCCESS: "âœ…",
            BilibiliQRStatus.EXPIRED: "âŒ",
        }
        emoji = status_emoji.get(code, "â“")
        print(f"{emoji} {message}")

    async with BilibiliQRCodeLogin(
        timeout=180,
        poll_interval=2.0,
        on_status_change=on_status
    ) as login:
        cookies = await login.login(
            save_qrcode_path="bilibili_qrcode.png",
            show_in_terminal=True
        )

        if cookies:
            # ä¿å­˜Cookie
            cookie_path = Path("data/bilibili_cookies.json")
            cookie_path.parent.mkdir(parents=True, exist_ok=True)

            with open(cookie_path, "w") as f:
                json.dump(cookies.to_dict(), f, indent=2, ensure_ascii=False)

            print(f"\nç™»å½•æˆåŠŸï¼Cookieå·²ä¿å­˜è‡³: {cookie_path}")
            print(f"SESSDATA: {cookies.sessdata[:20]}...")
            print(f"DedeUserID: {cookies.dede_user_id}")
        else:
            print("\nç™»å½•å¤±è´¥æˆ–è¶…æ—¶")


if __name__ == "__main__":
    asyncio.run(bilibili_qrcode_login_demo())
```

### 7.4 ä½¿ç”¨å·²ç™»å½•Cookieè®¿é—®Bç«™API

```python
import httpx
import json
from pathlib import Path


async def use_bilibili_cookies():
    """ä½¿ç”¨å·²ä¿å­˜çš„Cookieè®¿é—®Bç«™API"""

    # 1. åŠ è½½Cookie
    cookie_path = Path("data/bilibili_cookies.json")
    if not cookie_path.exists():
        print("è¯·å…ˆæ‰§è¡Œæ‰«ç ç™»å½•è·å–Cookie")
        return

    with open(cookie_path) as f:
        cookies = json.load(f)

    # 2. åˆ›å»ºå¸¦Cookieçš„å®¢æˆ·ç«¯
    async with httpx.AsyncClient(
        cookies=cookies,
        headers={
            "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) "
                          "AppleWebKit/537.36 (KHTML, like Gecko) "
                          "Chrome/120.0.0.0 Safari/537.36",
            "Referer": "https://www.bilibili.com/",
        }
    ) as client:
        # 3. è·å–ç”¨æˆ·ä¿¡æ¯
        resp = await client.get(
            "https://api.bilibili.com/x/web-interface/nav"
        )
        data = resp.json()

        if data["code"] == 0:
            user_info = data["data"]
            print(f"ç™»å½•ç”¨æˆ·: {user_info['uname']}")
            print(f"ç”¨æˆ·ID: {user_info['mid']}")
            print(f"ç­‰çº§: LV{user_info['level_info']['current_level']}")
            print(f"ç¡¬å¸: {user_info['money']}")
        else:
            print(f"è·å–ç”¨æˆ·ä¿¡æ¯å¤±è´¥: {data['message']}")


if __name__ == "__main__":
    import asyncio
    asyncio.run(use_bilibili_cookies())
```

### 7.5 Cookieæœ‰æ•ˆæ€§éªŒè¯

```python
import httpx
from typing import Optional


async def verify_bilibili_cookies(cookies: dict) -> Optional[dict]:
    """
    éªŒè¯Bç«™Cookieæ˜¯å¦æœ‰æ•ˆ

    Args:
        cookies: Cookieå­—å…¸

    Returns:
        æœ‰æ•ˆè¿”å›ç”¨æˆ·ä¿¡æ¯ï¼Œæ— æ•ˆè¿”å›None
    """
    async with httpx.AsyncClient(
        cookies=cookies,
        headers={
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                          "AppleWebKit/537.36 Chrome/120.0.0.0 Safari/537.36",
            "Referer": "https://www.bilibili.com/",
        }
    ) as client:
        resp = await client.get(
            "https://api.bilibili.com/x/web-interface/nav"
        )
        data = resp.json()

        if data["code"] == 0 and data["data"]["isLogin"]:
            return {
                "mid": data["data"]["mid"],
                "uname": data["data"]["uname"],
                "level": data["data"]["level_info"]["current_level"],
                "vip_type": data["data"]["vipType"],
            }

        return None


async def refresh_or_relogin():
    """æ£€æŸ¥Cookieï¼Œè¿‡æœŸåˆ™é‡æ–°ç™»å½•"""
    import json
    from pathlib import Path

    cookie_path = Path("data/bilibili_cookies.json")

    # 1. å°è¯•åŠ è½½å¹¶éªŒè¯ç°æœ‰Cookie
    if cookie_path.exists():
        with open(cookie_path) as f:
            cookies = json.load(f)

        user_info = await verify_bilibili_cookies(cookies)
        if user_info:
            print(f"Cookieæœ‰æ•ˆï¼Œå½“å‰ç”¨æˆ·: {user_info['uname']}")
            return cookies

        print("Cookieå·²å¤±æ•ˆï¼Œéœ€è¦é‡æ–°ç™»å½•")

    # 2. æ‰§è¡Œæ‰«ç ç™»å½•
    async with BilibiliQRCodeLogin() as login:
        result = await login.login()
        if result:
            with open(cookie_path, "w") as f:
                json.dump(result.to_dict(), f, indent=2)
            print("é‡æ–°ç™»å½•æˆåŠŸ")
            return result.to_dict()

    return None
```

---

## å…«ã€ä¸ç¬¬11ç« çš„å…³è”

æœ¬ç« ä»‹ç»çš„Bç«™æ‰«ç ç™»å½•æŠ€æœ¯åœ¨ç¬¬11ç« ç»¼åˆå®æˆ˜é¡¹ç›®ä¸­æœ‰å®Œæ•´åº”ç”¨ï¼š

### ä»£ç ä½ç½®
- **ç™»å½•æ¨¡å—**ï¼š`æºä»£ç /çˆ¬è™«è¿›é˜¶/11_è¿›é˜¶ç»¼åˆå®æˆ˜é¡¹ç›®/login/auth.py`
- **Cookieç®¡ç†**ï¼š`æºä»£ç /çˆ¬è™«è¿›é˜¶/11_è¿›é˜¶ç»¼åˆå®æˆ˜é¡¹ç›®/client/bilibili_client.py`

### æŠ€æœ¯è¦ç‚¹å¯¹åº”
| æœ¬ç« å†…å®¹ | ç¬¬11ç« å®ç° |
|---------|-----------|
| `BilibiliQRCodeLogin` ç±» | `login/auth.py` ä¸­çš„ç™»å½•é€»è¾‘ |
| `BilibiliCookies` æ•°æ®ç±» | `models/` ä¸­çš„æ•°æ®æ¨¡å‹ |
| Cookieæœ‰æ•ˆæ€§éªŒè¯ | `client/` ä¸­çš„è¯·æ±‚æ‹¦æˆªå™¨ |
| çŠ¶æ€ç æšä¸¾ | `config/bilibili_config.py` ä¸­çš„å¸¸é‡å®šä¹‰ |

### å­¦ä¹ è·¯å¾„

```mermaid
graph LR
    A[ç¬¬06ç« <br/>Cookieç®¡ç†] --> B[ç¬¬07ç« <br/>æ‰«ç ç™»å½•]
    B --> C[ç¬¬08ç« <br/>éªŒè¯ç å¤„ç†]
    C --> D[ç¬¬11ç« <br/>ç»¼åˆå®æˆ˜]

    style B fill:#e1f5fe
    style D fill:#fff9c4
```

æŒæ¡æœ¬ç« çš„æ‰«ç ç™»å½•æŠ€æœ¯åï¼Œä½ å·²ç»å…·å¤‡äº†Bç«™çˆ¬è™«çš„æ ¸å¿ƒè®¤è¯èƒ½åŠ›ï¼Œå¯ä»¥ç›´æ¥åº”ç”¨åˆ°ç¬¬11ç« çš„ç»¼åˆé¡¹ç›®ä¸­ã€‚

---

## æœ¬ç« å°ç»“

æœ¬ç« æ·±å…¥è®²è§£äº†æ‰«ç ç™»å½•å’ŒçŸ­ä¿¡éªŒè¯ç ç™»å½•çš„å®ç°ï¼š

1. **æ‰«ç ç™»å½•åŸç†**ï¼šäºŒç»´ç ç”Ÿæˆã€çŠ¶æ€è½®è¯¢ã€å‡­è¯ä¸‹å‘çš„å®Œæ•´æµç¨‹
2. **Playwright å®ç°**ï¼šä½¿ç”¨æµè§ˆå™¨è‡ªåŠ¨åŒ–å®ç°æ‰«ç ç™»å½•
3. **çŸ­ä¿¡ç™»å½•å®ç°**ï¼šæ‰‹æœºå·è¾“å…¥ã€éªŒè¯ç è·å–ã€ç™»å½•æäº¤
4. **ç»Ÿä¸€å°è£…**ï¼šä½¿ç”¨å·¥å‚æ¨¡å¼å°è£…å¤šç§ç™»å½•æ–¹å¼
5. **Bç«™å®æˆ˜**ï¼šå®Œæ•´çš„Bç«™æ‰«ç ç™»å½•å®ç°ï¼ŒåŒ…æ‹¬äºŒç»´ç ç”Ÿæˆã€çŠ¶æ€è½®è¯¢ã€Cookieæå–

æŒæ¡è¿™äº›æŠ€æœ¯åï¼Œä½ å¯ä»¥åº”å¯¹å¤§å¤šæ•°éœ€è¦ç™»å½•çš„çˆ¬è™«åœºæ™¯ã€‚

## ä¸‹ä¸€ç« é¢„å‘Š

ä¸‹ä¸€ç« æˆ‘ä»¬å°†å­¦ä¹ **éªŒè¯ç è¯†åˆ«ä¸å¤„ç†**ï¼ŒåŒ…æ‹¬å›¾ç‰‡éªŒè¯ç  OCR è¯†åˆ«ã€æ»‘å—éªŒè¯ç è½¨è¿¹æ¨¡æ‹Ÿç­‰æŠ€æœ¯ã€‚è¿™äº›æŠ€æœ¯åœ¨ç™»å½•å’Œçˆ¬å–è¿‡ç¨‹ä¸­ç»å¸¸é‡åˆ°ï¼Œæ˜¯çˆ¬è™«è¿›é˜¶çš„é‡è¦å†…å®¹ã€‚
